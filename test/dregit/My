#!/bin/bash
xset=""
[ "$1" = -x ] && shift && [ "$CI_ENV" = "yes" ] && xset=" -x" && set -x

usage()
  {
      local rc="$1"
      echo "usage:"
      echo "   My [-x] [-v] command <options>"
      echo ""
      echo "   with command:"
      echo "      help                           -- get this screen"
      echo "      name                           -- get my name"
      echo "      {password|passwd|pwd} pwd      -- set my password"
      echo "      cert {create password|revoke}  -- create or remove my certificate"
      echo "      project list                   -- list my projects"
      echo "      project <name> {+|-|=} pat     -- grant, revoke or list permission of a named project"
      echo "      {permission_reload|pr}         -- load current permission to 'authorize' container"
      echo ""
      echo "   options:"
      echo "      -x             set -x"
      echo "      -v             some commands support verbose mode"
      echo ""
      echo "where 'pat' is a pattern:"
      echo " - either an email address"
      echo " - or a local name (see 'My name')"
      echo ""
      exit $rc
   }

join_users()
   {
      grep -v DENIED \
      |  awk -v action="$1" '
            {  if ($1 == location){
                  userlist = userlist "|" $2
               }else{
                  if (location != ""){
                     printf "%-30s %-10s %s\n", location, action, userlist
                  }
                  location=$1
                  userlist=$2
               }
            }
            END{
                  if (location != ""){
                     printf "%-30s %-10s %s\n", location, action, userlist
                  }
            }'
   }

GenNginxPermFile()
   {
      sort -u \
      |  awk -v read="GET|HEAD" -v write="PUT|POST|PATCH|DELETE" '
            $2 == "read"   {   permstring="\"^/(" read  ")/("  $3 ")/$\""  }
            $2 == "write"  {   permstring="\"^/(" write ")/("  $3 ")/$\""  }
               {
                  if ($1 != location){
                     if (location != "") print  "    }"
                     printf "    location /%s/ {\n", $1
                  }
                  printf "       if ($acl ~ %-70s) { rewrite /.* /ok break; }\n", permstring
                  location=$1
               }
            END{  if (location != "") print  "    }"  }
            '
      echo '
    location ~ ^/auth/v2/$ {
       if ($acl ~ "^/(GET|HEAD)/(.*)/$"                   ) { rewrite /.* /ok  break; }
    }
    location /auth/v2/_catalog {
       if ($acl ~ "^/(GET|HEAD)/(.*)/$"                   ) { rewrite /.* /ok  break; }
    }
'
   }

GenPushPerm()
   {
      local file=$(mktemp /tmp/permission.XXXXXX) u p
      for p in       $(gitolite list-phy-repos | egrep -v "^gitolite-admin$|^testing$")
         do
            for u in $(gitolite list-users     | egrep -v "@all|@WRITERS|@OWNERS|@READERS|@CREATOR")
               do
                  echo "$p $u"
               done
         done \
      >  "${file}"
      (
         cat ${file} \
         |  gitolite access % % W any \
         |  join_users    write
         cat ${file} \
         |  gitolite access % % R any \
         |  join_users    read
      )  \
      |  GenNginxPermFile
      rm -f "$file"
   }

GenPushPermTest()
   {
      (
         cat write \
         |  join_users    write
         cat read \
         |  join_users    read
      )  \
      |  GenNginxPermFile
   }

##### ATTENTION:  external variables will be set:
#####   -  retval     stdout + stderr of ssh command
#####   -  rc         return code of ssh command
##### used external variables:
#####   -  xset       remote debug option
#####   -  verbose    should I print stdout+sterr after command is executed?
ssh_authorize()
   {
      retval=$(ssh root@authorize -- "$xset $*" 2>&1)
      rc=$?
      [ "$verbose" = yes ] && echo "$retval"
      return $rc
   }


verbose=""
[ "$1" = -v ] && shift && verbose="yes"
case "$1"
   in
      name)                  echo "$GL_USER"; exit 0;;
      c|cert|certificate) 
            case "$2"
               in
                  create)    ssh_authorize mk_client_cert "${GL_USER}" "$3";;
                  revoke)    ssh_authorize rm_client_cert "${GL_USER}"     ;;
                  *)         echo "cert '$2' is NOT supported" >&2; usage 2;;
               esac
            grep "download.uri" <<< "$retval"
            echo
            exit $rc
         ;;
      pwd|passwd|password)   ssh_authorize htpasswd "${GL_USER}" "$2"
                             exit $? ;;
      p|proj|project)        echo "unfortunately this is not implemented yet" &2 ;;
      pt|permtest)           GenPushPermTest;;
      pr|permission_reload)  GenPushPerm \
                             |  ssh_authorize permission_reload
                             exit $? ;;
      *)                     usage;;
   esac
